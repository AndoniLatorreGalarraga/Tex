\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}%esta linea no estaba en el original
\title{Complejidad Temporal}
\author{Andoni Latorre Galarraga}
\date{}

\begin{document}

\maketitle

\section{}
Hay que probar que:
$$
\exists c \in \mathbb{R}^+ \land \exists n_0 \in \mathbb{N} : \forall n \ge n_0 \quad c_1 n + c_2 \le c \cdot n
$$
Basta con tomar $c = \frac{c_2}{n_0} + c_1$.
$$
c_1 n + c_2 \le ( \frac{c_2}{n_0} + c_1 ) \cdot n
$$
$$
c_2 \le ( \frac{c_2}{n_0} + c_1 - c_1 ) \cdot n
$$
$$
c_2 \le \frac{c_2}{n_0} \cdot n
$$
$$
n_0 \le n
$$
Solo queda probar que $c \in \mathbb{R}^+$ para algun $n_0$:
$$
0 < \frac{c_2}{n_0} + c_1
$$
$$
- c_1 < \frac{c_2}{n_0} 
$$
Si $c_1 > 0$:
$$
n_0 > \frac{-c_2}{c_1}
$$
Si $c_1 < 0$:
$$
n_0 < \frac{-c_2}{c_1} \quad \Leftrightarrow \quad n_0 > \frac{c_2}{c_1}
$$
Si $c_1 = 0$:
$$
c_2 \le c \quad \land \quad n_0 > 0
$$
\section{}
Hay que probar que:
$$
\exists c \in \mathbb{R}^+ \land \exists n_0 \in \mathbb{N} : \forall n \ge n_0 \quad f(n) \le c \cdot g(n) \quad \Leftrightarrow \quad \exists c^\prime \in \mathbb{R}^+ \land \exists n_0 \in \mathbb{N} : \forall n \ge n_0 \quad g(n) \ge c^\prime \cdot f(n)
$$
$$
f(n) \le c \cdot g(n) \quad \Leftrightarrow \quad g(n) \ge c^\prime \cdot f(n)
$$
$$
\exists c \in \mathbb{R}^+ \quad \Leftrightarrow \quad \exists c^\prime \in \mathbb{R}^+
$$
$$
c^\prime = \frac{1}{c}
$$
\section{}
\textit{ComplejidadTemporal.py}
$$
1 + \sum_{i=1}^{len(v)} 1 = len(v) + 1 \in \Theta (len(v)) = \Theta (n)
$$
\section{}
\textit{ComplejidadTemporal.py}\\
Todo lo de dentro del \textit{for} tiene coste fijo.
$$
1 + \sum_{i=1}^{len(v)} 1 = len(v) + 1 \in \Theta (len(v)) = \Theta (n)
$$
\section{}
\textit{ComplejidadTemporal.py}\\
Todo lo de dentro del \textit{for} tiene coste fijo.
$$
\sum_{i=1}^{len(v)} 1 = len(v) \in \Theta (len(v)) = \Theta (n)
$$
\section{}
\textit{ComplejidadTemporal.py}\\
El peor caso es de la forma, \textit{t="aaaaaaaaaaaab" w="aaaab"}:
$$
1 + \sum_{i=1}^{m-n+1} ( 1 + \sum_{j=1}^{n} 1 ) = 1 + \sum_{i=1}^{m-n+1} ( 1 + n ) = (m-n+1) \cdot ( 1 + n ) = m + mn + n^2 \in O( m + mn + n^2 )
$$
\section{}
El peor caso es una lista donde h[i] $<$ h[i+1], la segunda condición del \textit{while} siempre es cierta y el valor de i se divide entre 2 cada vez, hasta ser menor o igual que 1.
$$
i_0 \to i_1 \to i_2 \to \cdots \to i_n \to \cdots \to i_f
$$
$$
i_0 \to \frac{i_0}{2} \to \frac{i_0}{4} \to \cdots \to \frac{i_0}{2^n} \to \cdots \to i_f \le 1
$$
$$
\frac{i_0}{2^f} \le 1 \quad \Rightarrow \quad \log_2 ( i_0 ) \le f
$$
El \textit{while} se repetira como mucho $\log_2 ( i_0 )$ veces, lo de dentro del bucle tiene coste fijo y $i_0 = \frac{k}{2}$. Por lo que lo de dentro del \textit{for} tendra un coste de $1 + \log_2 k$.
$$
\sum_{k=2}^{n} ( 1 + \log_2 k ) = n \cdot \sum_{k=2}^{n} ( \log_2 k ) = t(n)
$$
$$
2^{ \sum_{k=2}^{n} ( \log_2 k ) } = 2^{\frac{t(n)}{n}}
$$
$$
\prod_{k=2}^n 2^{\log_2 k} = 2^{\frac{t(n)}{n}}
$$
$$
\prod_{k=2}^n  k = 2^{\frac{t(n)}{n}}
$$
$$
\frac{n!}{2} = 2^{\frac{t(n)}{n}}
$$
$$
\frac{t(n)}{n} = \log_2 k! - 1
$$
$$
t(n) = n \cdot \log_2 k! -1 \in O(n\cdot \log k!)
$$
\section{}
\textit{ComplejidadTemporal.py}\\
Los resultados son:\\
Tamaño = 4 Tiempo = 1.5625e-05s\\
Tamaño = 8 Tiempo = 0.00015625s\\
Tamaño = 16 Tiempo = 0.063125s\\
Tamaño = 20 Tiempo = 1.055s\\
Tamaño = 24 Tiempo = 16.42671875s\\
He observado que $t(n) \approx 2^n \cdot 10^{-6}$ se ajusta bastante bien a los datos.
\end{document}
